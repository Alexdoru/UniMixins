import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

buildscript {
	repositories {
		gradlePluginPortal()
	}
	dependencies {
		classpath 'com.github.jengelman.gradle.plugins:shadow:6.1.0'
	}
}

repositories {
	maven {
		name = 'sponge'
		url = 'https://repo.spongepowered.org/maven/'
	}
	maven {
		url = "https://mvn.falsepattern.com/releases"
	}
	maven {
		name = "GTNH Maven"
		url = "http://jenkins.usrv.eu:8081/nexus/content/groups/public/"
		allowInsecureProtocol = true
	}
	mavenLocal()
}

configurations {
	shadowBridge
}

ext.mixinSource = project.findProperty("mixinSource") ?: "unimix"

if(mixinSource == "fabric" || mixinSource == "unimix"){
	def mixinVersion = mixinSource == "fabric" ? "0.11.4+mixin.0.8.5" : "0.11.5+mixin.0.8.5"
	if(project.hasProperty("local") || true) {
		mixinVersion += "-local"
	}
	def mixinGroup = mixinSource == "fabric" ? "net.fabricmc" : "io.github.legacymoddingmc"
	def mixinDep = mixinSource == "fabric" ? 'net.fabricmc:sponge-mixin:0.11.4+mixin.0.8.5' : 'io.github.legacymoddingmc:sponge-mixin:0.11.4+mixin.0.8.5-local'
	ext.mixinClassifier = "$mixinSource-$mixinVersion"
	dependencies {
		shadow("$mixinGroup:sponge-mixin:$mixinVersion") {
			exclude group: "org.ow2.asm"
		}
		shadow('org.ow2.asm:asm-tree:9.4')
		shadow('org.ow2.asm:asm-commons:9.4')
		shadow('org.ow2.asm:asm-util:9.4')
		
		shadowBridge("$mixinGroup:sponge-mixin:$mixinVersion") {
			transitive = false
		}
	}
} else if(mixinSource == "spongepowered"){
	ext.mixinClassifier = "spongepowered-0.8.5"
	dependencies {
		shadow('org.spongepowered:mixin:0.8.5')
		shadowBridge('org.spongepowered:mixin:0.8.5') {
			transitive = false
		}
		shadow('com.google.guava:guava:21.0')
		shadow('com.google.code.gson:gson:2.2.4')
		shadow('org.ow2.asm:asm-tree:9.2')
		shadow('org.ow2.asm:asm-commons:9.2')
		shadow('org.ow2.asm:asm-util:9.2')
	}
} else if(mixinSource == "gasmix"){
	ext.mixinClassifier = "gasmix-0.8.5-gasstation_7"
	dependencies {
		shadow('org.spongepowered:mixin:0.8.5-gasstation_7')
	}
} else if(mixinSource == "gtnh"){
	// Adapted from GTNHMixins's build script
	
	ext.mixinVersion = "0.8.5-GTNH-2"
	ext.mixinClassifier = "gtnh-$mixinVersion"
	def asmVersion = "9.4"
	dependencies {
		shadow("org.spongepowered:mixin:$mixinVersion")
		shadow("org.ow2.asm:asm-tree:$asmVersion")
		shadow("org.ow2.asm:asm-commons:$asmVersion")
		shadow("org.ow2.asm:asm-util:$asmVersion")
		shadow("com.google.guava:guava:21.0")
		shadowBridge('org.spongepowered:mixin:0.8.5')
	}
}

archivesBaseName = archivesBaseName.replace("-1.7.10", "-mixin-1.7.10")
version += "+${mixinClassifier}"

apply plugin: "com.github.johnrengelman.shadow"

if(mixinSource == "fabric" || mixinSource == "spongepowered" || mixinSource == "unimix") {
	// We want to *not* relocate ASM in the bridge classes. So we use a multi-step
	// build procedure:

	// 1. Create relocated Mixin jar with relocation, without the bridge classes
	task mixinJar(type: ShadowJar) {
		classifier = 'tmpMixin'
		configurations = [project.configurations.shadow]
		
		relocate 'com.google', 'org.spongepowered.libraries.com.google'
		relocate 'org.objectweb.asm', 'org.spongepowered.asm.lib'
		
		exclude 'org/spongepowered/asm/bridge/RemapperAdapter.class'
		exclude 'org/spongepowered/asm/bridge/RemapperAdapterFML.class'
		
		// Exclude stuff that's compiled for Java 16 
		
		exclude 'org/spongepowered/asm/service/modlauncher/*'
		exclude 'org/spongepowered/asm/launch/MixinTransformationServiceLegacy*'
		exclude 'org/spongepowered/asm/launch/MixinLaunchPlugin*'
		exclude 'org/spongepowered/asm/launch/MixinTransformationService*'
		exclude 'org/spongepowered/asm/launch/platform/container/ContainerHandleModLauncherEx*'
		
		exclude 'META-INF/services/cpw.mods.modlauncher.api.ITransformationService'
		exclude 'META-INF/services/cpw.mods.modlauncher.serviceapi.ILaunchPluginService'
		
		// Exclude jar-specific stuff
		
		exclude 'LICENSE.txt'
		exclude 'META-INF/MUMFREY*'
	}

	// 2. Create Mixin jar without relocation, with *only* the bridge classes
	task bridgeJar(type: ShadowJar) {
		classifier = 'tmpBridge'
		configurations = [project.configurations.shadowBridge]
		
		include 'org/spongepowered/asm/bridge/RemapperAdapter.class'
		include 'org/spongepowered/asm/bridge/RemapperAdapterFML.class'
	}

	// 3. Combine the two jars
	jar {
		//enabled = false
		dependsOn tasks.mixinJar
		dependsOn tasks.bridgeJar

		from zipTree(tasks.mixinJar.archiveFile).matching { exclude 'module-info.class' }
		from zipTree(tasks.bridgeJar.archiveFile).matching { include 'org/spongepowered/asm/bridge/*' }
		
		doLast {
			delete mixinJar.archiveFile
			delete bridgeJar.archiveFile
		}
		
		manifest {
			attributes (
				'TweakClass': 'org.spongepowered.asm.launch.MixinTweaker',
				'FMLCorePluginContainsFMLMod': 'true',
				'ForceLoadAsMod': 'true',
			)
		}
	}
} else if(mixinSource == "gasmix") {
	shadowJar {
		classifier = ''
		configurations = [project.configurations.shadow]
		
		manifest {
			attributes (
				'TweakClass': 'org.spongepowered.asm.launch.MixinTweaker',
				'FMLCorePluginContainsFMLMod': 'true',
				'ForceLoadAsMod': 'true',
			)
		}
	}
	
	jar {
		enabled = false
		dependsOn shadowJar
	}
} else if(mixinSource == "gtnh") {
	// Adapted from GTNHMixins's build script
	
	// We want to *not* relocate ASM in the bridge classes. So we use a multi-step
	// build procedure:

	// 1. Create relocated Mixin jar with relocation, without the bridge classes
	task mixinJar(type: ShadowJar) {
		archiveFileName.set("mixin-$mixinVersion-repack.jar")
		configurations = [project.configurations.shadow]

		mergeServiceFiles()

		exclude 'META-INF/MANIFEST.MF', 'META-INF/maven/**', 'META-INF/*.RSA', 'META-INF/*.SF'
		exclude '**/module-info.class'

		// we use this instead of 'org.spongepowered.libraries.org.objectweb.asm'
		relocate 'org.objectweb.asm', 'org.spongepowered.asm.lib'
		relocate 'com.google.common', 'org.spongepowered.libraries.com.google.common'
		relocate 'com.google.thirdparty.publicsuffix', 'org.spongepowered.libraries.com.google.thirdparty.publicsuffix'
	}
	
	// 2. Create Mixin jar without relocation, with *only* the bridge classes
	task bridgeJar(type: ShadowJar) {
		classifier = 'tmpBridge'
		configurations = [project.configurations.shadowBridge]
		
		include 'org/spongepowered/asm/bridge/RemapperAdapter.class'
		include 'org/spongepowered/asm/bridge/RemapperAdapterFML.class'
	}
	
	// 3. Combine the two jars
	jar {
		dependsOn tasks.mixinJar
		dependsOn tasks.bridgeJar

		from zipTree(tasks.mixinJar.archiveFile).matching {
			exclude "META-INF/*.RSA", "META-INF/*.SF", "META-INF/*.MF"
			exclude "META-INF/services/*.Processor"
			// Replaced by local classes
			exclude "org/spongepowered/asm/bridge/**"
		}
		from zipTree(tasks.bridgeJar.archiveFile).matching { include 'org/spongepowered/asm/bridge/*' }
		
		doLast {
			delete mixinJar.archiveFile
			delete bridgeJar.archiveFile
		}
		
		manifest {
			attributes (
				'TweakClass': 'org.spongepowered.asm.launch.MixinTweaker',
				'FMLCorePluginContainsFMLMod': 'true',
				'ForceLoadAsMod': 'true',
			)
		}
	}
}

// Obfuscation is useless because we're not compiling code referencing Minecraft classes
reobf.enabled = false
